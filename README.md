
# 게임 서버에서의 로그

> 게임 서버에서 로그 타입을 크게 두 가지로 분류한다면 게임 로그와 시스템 로그로 분류한다.
> 

## 게임 로그

- **게임 플레이에서 유저의 모든 중요 활동 기록**
    - ex) 돈이 증가했다거나, 거래했다거나, 아이템을 얻었다거나..
- **게임 로그는 로직의 결과가 아니라 DB에 저장할 결과를 로깅하는 것**
    - DB에 저장되는 시점에 로그도 DB에 함께 저장되는 것
        - 따라서 롤백이 되었다면 로그도 없게 되는 것
- **게임 로그는 최대한 컨텐츠 별로 상세하게 나누어 기록해야한다.**
    - ex) 돈을 획득했다 (X)  ⇒ 어떤 몬스터를 어디에서 잡았고 얼마에서 얻었다. (O)
- **로그는 내 캐릭터 데이터와 일치해야한다.**
    - 로그에 없는데 데이터가 반영 되었거나, 데이터 반영이 되지 않았는데 로그가 있으면 안되는 것
    - ex) 유저가 돈을 어떻게 모았는지 다 나와야한다.
- **게임 로그는 보통 문제가 생겼을 때 증거를 확인하는 목적**
    - 실제 게임 데이터와 100% 일치해야한다.
- **게임 로그는 파일 저장이 아닌 DB에 저장**
    - **DB에 저장한다는건 유지 및 관리, 검색을 적극적으로 하겠다는 것**
        - 보통 로그 남기는 기간은 N년치 정도..
    - **DB 저장은 트랜젝션(원자적인 저장 단위)으로 처리**
        - 거래를 예시로 든다면 한 유저에서 돈을 빼고 더하고 하는 등의 과정이 원자적이어야함
            - 이러한 행동 자체를 트랜젝션으로 묶는다.
                - 100% 되거나 안되거나
                - 중간 과정이 있으면 안됨
- **게임 로그 저장과 데이터 반영을 트랜잭션으로 묶어서 처리하는 것이 가장 좋다.**
    - 게임 데이터 DB와 로그 DB가 분리되어있다면 트랜잭션 불가능
    - 게임 로그의 목적만 보고 한다면 같은 DB에 없고 트랜잭션으로 묶이는게 베스트이지만, 불가능하다면 최대한 같은 순간에 반영하게끔 해야한다.
        - 트랜잭션을 안하더라도 DB 쿼리와 함께 로그 쿼리 전송
            - 걱정되는 사항은 이 짧은 찰나에 문제가 생길 가능성
                - 갑자기 서버에 문제가 생긴다거나
                - 가능은 하지만 희박할 거임
            - 이러한 희박할 가능성에 스트레스를 안받고 그냥 하기도한다.
                - 따라서 트랜잭션 없이 DB 쿼리와 로그 전송이 해도 말이 안되는건 아님
- 게임 로그를 저장하는 코드는 DB 저장하는 시점에 존재해야기 때문에 특정 모듈로 존재하기보단, 게임에 종속된 형태의 코드로써 존재한다.
    - 게임 로그는 라이브러리화 하기 어렵고 게임 개발시 DB 저장 방식에 따라서 그 때 제작하는게 일반적
- **중요한건 로그 테이블을 분류별로 나누지 않고 기간별로 나눈다.**
    - **퀘스트 로그, 아이템 로그… 이렇게 나누는건 좋지 않음**
        - 관리가 어려움
    - **게임 로그 목적 자체가 월드 안에서의 데이터 변화를 기록하는 것**
        - 월드의 cctv 같은 것
        - 그래서 분류별로 나누는건 적합하진 않음
    - 규모에 따라 다르겠지만, 한 월드 당 (월드 당 게임 서버 1개 있고)‘주~월’ 단위가 일반적

## 시스템 로그

- **개발자 디버깅을 위해 필요한 로그**
- **시스템 로그는 대부분 파일로 저장**
- **라이브에서 찍을 로그와 디버깅에서 찍을 로그가 다르므로 서로 분류되어야한다.**
    - 전처리를 통해서 라이브용 디버깅/개발용 디버깅하는 방법
        - 그러나 이는 비권장
            - 빌드를 새로해야하므로..
    - 런타임에 if로 변수 체크하여 분류하는 방법
        - 빌드를 새로 하지 않고 로그 레벨을 실시간으로 바꿀 수 있도록..
        - 권장하는 방법
            - 서비스 환경에서도 디버깅 로그를 확인하고 싶을 수 있으니까

> 정답은 없다. 그냥 회사 규칙에 따르면 된다.
> 
- **디버깅 용으로 다 찍으면 너무 느리기 때문에 라이브에서는 중요한 로그만 남긴다.**
    - **비정상적인 상황**
        - **결함**
            - **당장 서버를 중단해야함**
        - **당장 중단할 정도는 아니지만 확인이 필요한 것들**
            - **링 버퍼가 다 차거나..**
    - **이러한 상황을 모두 미리 파악해야 하고, 이를 로깅할 수 있는 기능은 미리 만들어야한다.**

### 시스템 로그 레벨

- **시스템**
    - 꼭 남겨야 하는 것들
        - 필수적인 초기화 진행 상황 등..
        - DB 연결 등의 초기화 관련 진행 상황은 꼭 남길 것
    - 주로 서버 첫 가동이나 끌 때 많이 남겨질 것임
- **에러**
    - 라이브에서도 꼭 찍어야하는 것들
    - 일어나선 안되는 상황이지만 서버를 당장 죽일 필요 없을 때 남기는 것
        - 위험한 상황이면 debugbreak로 서버를 죽이는게 맞을 것..
- **디버깅**
    - 디버깅 환경에서만 남기는 것들

### 시스템 로그의 구현

- 전역 함수 또는 싱글톤
    - 원장님은 전역 함수 선호
- Debug, Error, System 로그 레벨
    - 전처리가 아닌 남길까 말까를 런타임에 동적으로 코드로 판단하게 하는 것을 권장
        - 서비스 중인데도 서버를 조작하여 로그 레벨을 바꿀 수 있게끔
        - 물론, 불필요한 코드 남기는게 싫으면 전처리 해도 상관은 없음
- 기간 + 분류(타입) 별로 분류 되는 것을 권장
    - ex) 201509_Battle.txt
    - DB는 검색이 쉬운데, 텍스트로 남기는 시스템 로그는 분류별로 나누지 않으면 보기 힘듬
    - 물론 이것도 사람마다 선호가 다르므로 알아서 결정
- **로그 카운팅을 남기는 것 권장**
    - 함수 안에서 interlockedIncrement 하면서..
    - 같은 초 안에서 순서 확인을 못할 수도 있으니 count로 같은 초에 대해서 순서 남길 필요있음
    - count는 껐다키면 다시 초기화 되도 상관없음
- 로그도 락을 걸 필요가 있음
    - 여러 스레드에서 로그 함수를 여기저기 호출
    - 로그 왔을 때 파일 안열리면 누가 쓰고 있다는것으로 판단하고 뺑뺑이 도는 방법이 있으나 이건 너무 무식하니 락을 거는 방법 권장
        - 분류별로 락
        - ex) Battle 로그, Item 로그..
- 가변인자 쓸 거면 c 말고 winapi에 있는거 사용
    - c 런타임라이브러리 있는거 말고, Strsafe.h
        - StringCchVPrint
            - 버퍼에 대해 초과되는 상황을 고려한다면 StringSbCatA 사용해도됨
        - StringCbCatA는 넘어간 부분은 짤라서 리턴
            - 로그가 짤렸다는 결과가 나오면 어떻게 할 것인가
                - 짤렸다는 로그를 추가로 남기고 그냥 넘어가거나 크기를 다시 늘려서 재시도
                - 로그에서는 서버를 죽이는 코드를 넣으면 안됨
- Hex 16진수 로그도 상황에 따라 필요하니 만들어둘 것
    - 메모리 자체를 로깅하고 싶을 때
    - 어떤 버퍼나 객체의 덤프 느낌

# 로그를 남기는 방법들

**로그를 남기는 방법에 따라 유실의 범위가 달라진다.**

1. **로그 함수가 리턴하는 순간 디스크에 무조건 저장**
    - **조금 느리더라도 안전하게 저장하는 방법**
    - 처음 CreateFile 할 때 옵션으로 노버퍼링을 걸고 즉시 동기적으로 디스크에 써야한다.
        - 일반적인 write로는 불가
            - 파일 캐시에 저장되기 때문에 파일을 닫아도 즉시 디스크 저장을 보장 못함
            - 언제 디스크에 저장하는가는 운영체제가 정함
        - 쓰기를 100% 보장하지만 엄청 느리다.
    - 게임 서버에서 쓰기에는 약간 오바인 것 같다. (내 생각)
        - 컴퓨터 전원이 나가는 상황까지 고려할 필요는 없을 것 같음
        - 대신 금융권은 필수로 있어야할 것이다.
2. **로그 함수가 리턴해도 즉시 디스크에 저장되지 않으나 전원이 꺼지지 않는 이상은 로그의 저장은 보장**
    - 일반적인 write 함수 등으로 파일 캐시에 저장하는 형태가 가장 일반적인 형태
        - 프로세스가 뻑이 나는 경우에도 유실 안된다.
        - 대신에 컴퓨터 전원 자체가 나가면 유실
    - 파일을 열고 쓰고 닫고 하면 느리긴하나 안전
        - 이게 싫으면 파일을 계속 열고나서 쓰고 플러시 때리면서 가도 됨 (마지막 일부 유실 가능)
3. **비동기적으로 로그 저장 스레드를 따로 빼서 저장**
    - 로깅할 데이터를 카피 떠서 스레드에게 전달
        - 그 이후에는 스레드가 알아서
    - 가장 빠르지만 유실의 리스크가 존재
        - 프로세스가 뻑이 나면 아직 저장하지 못한 것은 유실
    
    > 지금까지의 내 경험으로는 프로세스가 크래시 날 때 원인을 파악하기 위해서 로그를 남기는 경우가 많았다. 그래서 3번은 선택하지 않을 것이다.
    > 

## 로그 찍는 속도에 대한 고민

- 애초에 영향이 갈 정도로 로그를 많이 남기는 거 자체가 문제이다.
    - 정말 확인이 필요한 것 들만 남긴다.

> 단 웹 서버는 사용자 활동에 대한 모든걸 다 남김
> 
> - 그래서 웹 서버는 로그 찍는 속도가 중요
> - 빠른 속도로 로그를 찍는 오픈 소스도 있음